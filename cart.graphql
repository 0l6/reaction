# Schema

# TODO: This is a new concept for Reaction. Discuss.
type Session {
  # Avoid transporting, storing, and logging session ids to minimize security
  # exposure. An exposed session ID can be hijacked. Use a hash of the session
  # ID so taht we can freel use it.
  hashId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  expiresAt: DateTime!
}

type ShippingParcel extends Node{

}

# Products are added to carts as a CartItem.
type CartItem extends Node {
  _id: ID!
  product: CatalogItemProduct! # TODO: Right type here?
  # QUESTION: Can users have separate carts in different shops, or always
  # shared cart? Configurable in other systems. Asking as shopId is not
  # currently required.
  shop: Shop
  quantity: Int!
  metafields: [Metafields]
  title: String
  type: String
  parcel: ShippingParcel
  # What is this? It's optional.
  cartItemId: String
  # What is this? Any way around the blackbox? Does it store info from the payment transaction?
  # Perhaps it should not be visible to the customer? Require special permissions.
  #transaction: JSONObject  # OMIT: Customer should not see this!

  # What is this? Any way around the blackbox?
  taxData: JSONObject
  taxRate: Float
  # Any way around the blackbox?
  shippingMethod: JSONObject
}

type Cart extends Node {
  _id: ID!

  shop: Shop!

  # We're currently using User on the Cart.
  # Enforce database uniqueness such that an account only has one cart.
  account: Account

  # We currently have sessionId, this should be hashed for security purposes.
  # Should be required, or we rethink how cart flows work (not automatically
  # create a cart). May be this way already?
  session: Session!
  email: Email
  items: [CartItem]
  shipping: [Shipment]! # TODO: What is this?
  billing: [Payment]! # TODO: What is this?
  tax: Float
  taxes: [JSONObject] # TODO: What is this?
  taxRatesByShop: JSONObject # How is this used?
  discount: Float
  workflow: Workflow
  createdAt: TimeStamp!
  # TODO: Should we have an expires at cart read-only attribute? This can be
  # calculated from updatedAt timestamp and added to record. Would keep expiry
  # dynamic.
  #expiresAt: TimeStamp!
  updatedAt: TimeStamp!
}

# Query
cart(): Cart

# Mutations

# TODO: How do we handle sessions in the API? I don't think it's safe to send
# the session ID to the API. It might be best for the API to read session data
# from a cookie. In fact, it is more secure to store session/token info in
# cookies that in LocalStorage. Discuss with the team.
input CreateCartInput {
  #accountId: String       # TODO: Better to make this implicit.
  #sessionHash: String!    # TODO: Better to make this implicit.
  items: [CartItemInput]!  # NOTE: Don't allow creation of an empty cart?
  shopId: String!          # NOTE: We'll require shopId though it's not in current code.
}

# Input for adding item(s) to a cart.
input CartItemInput {
  productId: String! # NOTE: This must be the variant, or "sellable" product!
  quantity: Int!
  shopId: String
}

input UpdateCartItemInput {
  cartItemId: String!
  quantity: Int!       # Absolute value.
}

# Create a new cart.
# Enforce that at least one item is provided so we don't create empty carts.
# Check for an existing cart (and return it) before creating a new one.
createCart(input: CreateCartInput!): Cart!

# Add an item to cart.
# If the item already already exists in the cart, then increment quantity.
# TODO: Consider returning connection?
addCartItems(items: [CartItemInput]!): Cart!

# Once added to cart, items should be referenced by their cart item ID.
# Enforce that at least one item is in the list. Perhaps we could force that
# to be singular?
removeCartItems(cartItemIds: [String]!): Cart!

# If cart item input is set to 0, then remove the item.
updateCartItems(modifier: [UpdateCartItemInput]!): Cart!

# Obtain the current user from token and merge session cart into user's
# existing cart. If no cart is found in the DB, bind session cart to user and
# return that cart. Always prefer (and merge into) existing user cart. Remove
# session cart when upon successful merge.
#
# Remove session id from cart upon successful merge.
#
# The client must call when the user logs in? How to enforce this?
# Current sesssion cart should be found implicitly from request/token.
mergeCart(): Cart!


## DEFER ALL BELOW TO CHECKOUT SLICE

# TODO: Do we need to add this information to the cart? Can we defer it all to
# the order? Should we? Doesn't seem to belong in cart. Also, there's usually
# no reason that the derived calculations (tax, shipping, etc) must be
# displayed in the cart.
setCartEmail(cartId: String!, email: String!): Cart!
setCartPaymentAddress(cartId: String!, paymentAddress: CartPaymentAddressInput!): Cart!
setCartShipmentAddress(cartId: String!, CartShipmentAddressInput!): Cart! # TODO: Should this be on the item?
setCartShipmentMethod(cartId: String!, shipmentMethod: CartShipmentMethodInput!): Cart!

# TODO: Any particular reason this is "UserCurrency" and not "Currency"?
# Can we change to "setCartCurrency"?
#setCartUserCurrency(cartId: String!, currency: CartCurrencyInput!): Cart!
setCartCurrency(cartId: String!, currency: CartCurrencyInput!): Cart!

# TODO: Is there a reason to call this "submitCartPayment"? Can we make it
# consistent with the "setCartXXX" names above, as "setCartPayment"?
submitCartPayment(cartId: String!, payment: CartPaymentInput!): Cart!

# TODO: Ignore for now. How do we handle converting to order?
# Should this be createOrder?
createOrderFromCart(): Order
